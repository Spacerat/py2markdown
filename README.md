```py
#!/usr/bin/env python3
```

# py2markdown

py2markdown converts a python file to a markdown file where all top level
level `""" comments """` are rendered as markdown, and everything else
is rendered as code blocks.

This file was generated by running:

```sh
./py2markdown.py py2markdown.py > README.md
```


```py
import ast
import parser
import re
from pathlib import Path


def process_source(text):
    """ Convert and print some text """
    # Get the start/end line of each omment
    comment_lines = get_comment_lines(text)

    lines = text.split("\n")
    comment_lines.append((len(lines), None))
    last = 0

    for (firstline, lastline) in comment_lines:
        code = "\n".join(lines[last:firstline])
        if code.strip():
            print(f"```py\n{code.strip()}\n```")
        if lastline:
            print(extract_comment("\n".join(lines[firstline:lastline])))
        last = lastline


def extract_comment(comment):
    """ Extract the content of a comment from a quoted comment string """
    return re.match(
        r"^\s*(?:(?:\"(?:\"\")?)|(?:\'(?:\'\')?))(.*?)(?:(?:\"(?:\"\")?)|(?:\'(?:\'\')?))\s*$", comment, flags=re.DOTALL
    ).group(1)
```

The trick is to use the _AST_ module to parse the file and get
the bounds of all top level string expressions.

```py
def get_comment_lines(text):
    """ Get the start and end line numbers of all top-level string nodes """
    st = ast.parse(text, "source.py")
    comment_lines = []

    for node in st.body:
        if isinstance(node, ast.Expr) and isinstance(node.value, ast.Str):
            comment = node.value.s

            lastline = node.lineno
            firstline = lastline - len(comment.split("\n"))
            comment_lines.append((firstline, lastline))

    return comment_lines
```

This ties it all up into a command.

```py
if __name__ == "__main__":
    import click

    @click.command()
    @click.argument("src", type=click.File("r"))
    def run(src):
        process_source(src.read())

    run()
```
